	Лекция 13 (Асинхронное i/o)
i/o: блокирующее, не блокирующее

Блокирующее чтение сокета не подразумевает, что будет 
заполнен весь буффер. Достаточно будет и 1 байта.
Т.е. не выйдем из функции пока что-то не придет.

Как серверные программы на блокирующем i/o завершают свою 
работу, если они ожидают на методе connect?
Просто делаем connect самому себе + выставляем какой-нибудь
флаг завершания.

Неблокирующий i/o реализуется той же самой функцией, но с
выставлением специального флага: fcntl(O_NONBLOCK);

В таком случае мы выйдем сразу, если не имеется никаких
данных.

Сигналы по своей природе являются асинхронным ipc.
Если мы можем спрогнозировать в какой момент времени какие данные мы будем
обрабатывать, то это синхронный механизм. Иначе - асинхронный.

Т.е. критерием асинхронности является неожиданность. Мы не можем знать
в какой момент времени начнется обработка данных.
(наш поток)								выполняет события из очереди
-----------------			инициируер работу		(может быть > 1 потока)
|   Initiator	|			-----------------		-------------------------
-----------------			| proactor	|------------->	| asynk operation	|
	|				-----------------		| demultiplexor		|
	|------------------------------------------------		-------------------------
	|			|			|			| (poll)
-----------------	-----------------	-----------------	-----------------
| completion	|	| async		|	| asynk opera-	|(fill)	|		|
| handler	|	| operation	|	| tion processor|-------| QUEUE EVENTS	|
| (callback)	|	| (r/w, etc...) |	| (fill queue	|	|		|
-----------------	-----------------	| of events	|	-----------------
						----------------- 	(складываются уже с данными)

Т.е. создаем операцию в нашем процессе, а обрабатывается событие в другом.
Можно создать операцию внутри обработчика события и тем самым сделать непрерывную 
рекурсивную обработку чего-либо.

Asynk operation processor работает поверх функции select (multiplexer)
в отдельном потоке. (select это блокирующая функция)

Аналогичные ф-ии селекторы:
	- select (O(n) сложность при обработку соединений от 
	числа дескрипторов)
	- poll
	- epoll (скорость работы не зависит от числа 
	дескрипторов)

Современные приложения, если OS поддерживает epoll, используют
именно его, т.к. данная функция намного производительней + 
существует несколько режимов работы, сильно схожих с 
асинхронным.

Для нашего процесса операция действительно выглядит асинхронной, но
на самом деле мы это скрыли в блокирующем вызове select в другом потоке.

В asynk operation processor мы реализуем так называемый паттерн
reactor, когда мы реагируем на какое либо внешнее событие.

Но не обязательно имитировать асинхронное вреимодействие через другой
поток + блокирующий вызов select. OS предоставляет специальный интерфейс
AIO (это часть POSIX-а). 

В той же манере позволяет заказать обработку некоторого события у OS.
Но в каком потоке будет исполняться обработка?
	- можно заказать обработку, через специальный обработчик сигналов
	- можно сделать в специальных потоках, чтобы они сделали что-то
	после получения события
Т.е. часть схемы может быть делигирована на уровень ниже в ядро OS.
Заказ какого-то события а не ожидание его говорит нам о том, что OS
может сделать некоторые вещи эффективней (См. /dev/epoll).

Виртуальное устройство, которое позволяет не копировать по нескольку 
раз буффер с данными.

Заказать можно лишь 1 асинхронную операцию на 1 сокет. 
После выполнения которой можно заказать ещё одну.
(т.к. мы не знаем порядок выполнения операции)

* Корутины (сопрограммы) - делают асинхронный по природе код, 
последовательно читаемым. (В С++20 вошли в стандарт как стандартное решение)

* Так же существует actor-ная модель взаимодействия. Когда декомпозируем такую
абстракцию как корутины на общение сообщениями между разными функциями.
- данная модель хорошо ложится для проектирования конечных автоматов.
Реализована как стандарт в {Scala, erlang}

class A {
	process()
	send()
}
методы могут исполняться на любых потоках
