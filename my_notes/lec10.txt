	Лекция 10 (Транзакционная память)

* Software transaction memory (STM) - прослойка между приложением и RAM
ЯП которые не имеют доступа к памяти (Java, c#)
- Haskell имеет STM как стандарт ЯП
- В реальной промышленности STM не применяется

* Hardware transaction memory (HTM) - сущ. поддержка со стороны
расширений CPU. Компилятор преобразует некоторые абстракции
в специальные низкоуровневые инструкции

Пропускная способность SkipList (см структуру) на транзакционной
памяти значительно превосходит обычную грубую синхронизацию почти
на порядок в числе операций

	ПРЕИМУЩЕСТВА
1) отсутствие блокировок
2) лучшая производительность <=> лучшая утилизация CPU
3) выше уровень абстракции - что защищаем а не как
4) возможность отката

	Как может быть реализована аппаратная поддержка:
Добавляем доп. флаг в состояние линий кеша процессора (находится
ли данная кеш-линиия в транзакции или нет) + специальные инструкции 
для установки и снятия этого флага

Если другой процессор попробует что-то сделать с этой памятью - то он 
подгрузит кеш-линию из другого процессора (или уже подгрузил). В таком случае
исходный процессор будет уведомлен о том, что кто-то попытался обратиться
к памяти и транзакция будет откачена.

Если у нас процессор Intel > 2012 года, то скорее всего есть данная аппаратная
поддержка (У AMD процессоров данного расширения пока что нет)
* TSX (Transactional Synchronization Extensions) - просто дополнительный
набор комманд (начать транзакцию, закончить, отменить и т.д.)

	Ограничения:
1) Структура должна вмещаться в кеш (1-го уровня ~[1-3] MiB), иначе за 1 
транзакцию невозможно обновить структуру
2) Архитектурные ограничения (поддержка)
3) Должны уложиться по времени в квант времени, выделенный планировщиком

См. графики вероятности отката от: 
	- размера структуры
	- числа операция над структурой

В современном GCC мы можем использовать TM начиная с GCC 6.1
(реализая в libitm.so (intel transaction memory))

Use flag: -fgnu-tm, используем код в секции 'synchronized { code... }'

Если не проверяем явно поддержку со стороны архитектуры: выкидывается исключение
'неизвестная инструкция'

Существуют статусы выполнения транзакций в соответсвии с которыми можно
обрабатывать результат

	Как сочетаются барьеры памяти и TM?
На момент окончания транзации процессор применет все изменения в 
invalidation queue и тем самым все корректно отработает

Но если есть логика, которая завязана на memory reordering то
атомики использовать придется
// тема сложная, сказать точно нельзя

В случае TM существует некоторый промежуточный слой в приложениях (примитивы)
который мы можем оптимизировать и это повлияет на большое число приложений
в мире

Существует 2 API for TM
	1) для встраивания в примитивы с fallback-ом на честные примитивы
	2) для настоящей работы как с транзакциями

