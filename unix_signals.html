<HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r"><TITLE>
OpenNET: статья - Правила использования сигналов в Unix (signal proccess faq select gcc)
</TITLE>
<meta name="KeyWords" content="signal, proccess, faq, select, gcc">
</HEAD><BODY BGCOLOR="#DDE1C2" TEXT="#002040">
<LINK REL="stylesheet" href="/opennet4.css" type="text/css">
<!--htdig_noindex-->
<FORM method="get" action="http://www.opennet.ru/search.shtml">
<aside>
<div style="width: 100%; text-align: right; font-size: 70%; background: #E9EAD6; margin-bottom:-10px;">
Профиль: <b><a href="/~" rel="nofollow" title="/~ - сводная страница участника"><u>Аноним</u></a></b> (<a href="https://www.opennet.ru/cgi-bin/openforum/vsluhboard.cgi?az=login">вход</a> | <a href="https://www.opennet.ru/cgi-bin/openforum/vsluhboard.cgi?az=user_register">регистрация</a>) <span style="text-decoration: line-through red;"><a href="https://www.opennet.ru/base/dev/unix_signals.txt.html" title="Страница открыта без HTTPS">HTTPS</a></span>

</div>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH="100%">
<TR>
<TD width=300 VALIGN="BOTTOM" BGCOLOR="#E9EAD6" style="background: #E9EAD6 url('/back.gif') repeat-x bottom left">
<A HREF="/"><IMG SRC="/opennet2.gif" HEIGHT=60 WIDTH=249 ALT="The OpenNET Project" BORDER="0"></A><br>
</TD>
<TD WIDTH=100 ALIGN=CENTER BGCOLOR="#E9EAD6" style="background: #E9EAD6 url('/back.gif') repeat-x bottom left">

</TD><TD WIDTH=50% ALIGN=CENTER BGCOLOR="#E9EAD6" style="background: #E9EAD6 url('/back.gif') repeat-x bottom left;padding-bottom:10px;">
<table width="100%" border=0>
<tr>
<td width="22%">
 <A HREF="../../opennews/" class="h"><b>НОВОСТИ</b></A> (<a href="../../news/opennet.shtml" class="h">+</a>)
</td><td width="18%%">
  <A HREF="../../mp/" class="h"><b>КОНТЕНТ</b></A>
</td><td width="14%">
  <A HREF="http://wiki.opennet.ru" class="h"><b>WIKI</b></A>
</td><td width="14%">
   <A HREF="../../man.shtml" class="h"><b>MAN'ы</b></A>
</td><td width="16%">
   <A HREF="../../forum/" class="h"><b>ФОРУМ</b></A>
</td><td width="16%">
<A HREF="../../search.shtml" class="h" onMouseOver="document.getElementById('form12').style.display='block';">Поиск</A>&nbsp;(<A HREF="../../keywords/" class="h">теги</A>)
<INPUT id="form12" style="display: none;" type="text" size="10" name="words" value="" title='для поиска в google наберите "g фраза"'>
</td></tr>
</table>

</TD><TD align=right WIDTH=20% BGCOLOR="#E9EAD6" style="background: #E9EAD6 url('/back.gif') repeat-x bottom left;padding-bottom:5px;">

<a href="https://www.opennet.ru/opennews/opennews_all_utf.rss"><img src="/img/rss.png" height="16" width="16" alt="RSS" title="RSS" border="0"></a>&nbsp;<a href="https://twitter.com/opennetru"><img src="/twitter.png" height="16" width="16" alt="twitter" title="Twitter" border="0"></a>&nbsp;<a href="https://vk.com/opennet"><img src="/img/vkontakte.gif" height="16" width="16" title="ВКонтакте" border="0"></a>&nbsp;<a href="https://zen.yandex.ru/opennet"><img src="/img/zen.png" height="16" width="16" title="Yandex Zen" border="0"></a>&nbsp;<a href="https://www.facebook.com/OpenNet.News/"><img src="/img/facebook.gif" height="16" width="16" title="Facebook" border="0"></a>&nbsp;<a href="https://telegram.space/opennet_ru"><img src="/img/telegram2.png" height="16" width="16" title="Telegram" border="0"></a>
</TABLE>
</aside>

<style>
    .hdr_mobile {
	text-align: center; 
	display: none;
	margin: 0px;
	padding: 0px;
    }
</style>
<div class=hdr_mobile>
<div style="margin-left: auto; margin-right: auto; width: 100%; height: 70px; border:1px solid #b0b190; min-width: 360px; max-width: 600px; background: #E9EAD6 url('/back.gif') repeat-x bottom left;">
<div style="float:left; width: 249px; height: 60px; margin-top: 10px;">
<A HREF="/"><IMG SRC="/opennet2_lite.gif" style="height: 60px; width: 249px; border: 1px;" ALT="The OpenNET Project / Index page"></A>
</div>
<div style="float: left; text-align: center; height: 70px; width: 331px; padding: 5px; margin-left: 10px;">
<br><small>[ <a href="/opennews/">новости</a>&nbsp;/<a href="/opennews/?full_lines=15&amp;lines=15&amp;mid_lines=00">+++</a> | <a href="/forum/">форум</a> | <a href="http://wiki.opennet.ru">wiki</a> | <a href="/keywords/">теги</a>
| <a href="tg://resolve?domain=opennet_ru"><img src="/img/telegram2.png" height="16" width="16" title="Telegram" border="0" style="margin-bottom: -4px;"></a>
]</small>
</div>
</div>
</div>
<div style="clear: both;"></div>


<div style="float: left; width: 279; text-align: left;padding-right: 60px;" id=adv>
</div>
<div style="padding-top: 0px;position:absolute;left:50%;margin-left:-235px;width:470px;" id=adv2>
</div>
<div style="width: 279;float: right;" id=adv3>
</div>
<div style="clear: both;"></div>
<br>
</FORM>
<!--/htdig_noindex-->


<CENTER><H3><FONT COLOR="#000090">
Правила использования сигналов в Unix (signal proccess faq select gcc)
</FONT></H3></CENTER>
<BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=1 BGCOLOR="#B0B190" WIDTH="100%">
<TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 BGCOLOR="#E9EAD6" ALIGN=CENTER WIDTH="100%">
<TR BGCOLOR="#000000"><TD COLSPAN=7><IMG SRC="/p.gif" HEIGHT=1 WIDTH=1 ALT=""></TD></TR>
<TR ALIGN=CENTER>
<TD><small><A HREF="/cgi-bin/opennet/jump.cgi?name=unix_signals.txt&ref=prev">&lt;&lt; Предыдущая</A></TD>
<TD><small><A HREF="/cgi-bin/opennet/jump.cgi?name=unix_signals.txt&ref=index">ИНДЕКС</A></TD>
<TD><small><A HREF="/search.shtml">Поиск в статьях</A></TD>
<TD><small><A HREF="/cgi-bin/opennet/jump.cgi?name=unix_signals.txt&ref=raw">src</A></TD>
<TD><small><A HREF="/cgi-bin/opennet/jump.cgi?name=unix_signals.txt&ref=setbookmark">Установить закладку</A></TD>
<TD><small><A HREF="/cgi-bin/opennet/jump.cgi?name=unix_signals.txt&ref=getbookmark">Перейти на закладку</A></TD>
<TD><small><A HREF="/cgi-bin/opennet/jump.cgi?name=unix_signals.txt&ref=next">Следующая &gt;&gt;</A></TD>
</TR><TR BGCOLOR="#000000"><TD COLSPAN=7><IMG SRC="/p.gif" HEIGHT=1 WIDTH=1 ALT=""></TD></TR>
</TR></TABLE></TD></TR></TABLE>
<PRE>
<b>Ключевые слова:</b> <A href="/cgi-bin/opennet/ks.cgi?mask=signal">signal</a>, <A href="/cgi-bin/opennet/ks.cgi?mask=proccess">proccess</a>, <A href="/cgi-bin/opennet/ks.cgi?mask=faq">faq</a>, <A href="/cgi-bin/opennet/ks.cgi?mask=select">select</a>, <A href="/cgi-bin/opennet/ks.cgi?mask=gcc">gcc</a>,  (<a href="/cgi-bin/opennet/ks.cgi?mask=signal%20proccess%20faq%20select%20gcc">найти похожие документы</a>)<br>
<FONT COLOR="#0000C0">From: Valentin Nechayev &lt;<A HREF="mailto:netch@segfault.kiev.ua">netch@segfault.kiev.ua</A>&gt;</FONT>
<FONT COLOR="#0000C0">Newsgroups: fido7.ru.unix.prog</FONT>
<FONT COLOR="#0000C0"><B>Subject: Правила использования сигналов в Unix</B></FONT>
<FONT COLOR="#0000C0">Date: Tue, 26 Aug 2003 08:07:19 +0000 (UTC)</FONT>

Основной текст написал: Yar Tikhiy &lt;<A HREF="mailto:yar@comp.chem.msu.su">yar@comp.chem.msu.su</A>&gt;

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Предисловие

Если судить по исходникам популярных программ и обсуждениям Usenet
за последние лет 20, то обработка сигналов Unix -- это игра, в
которой большинство участвует, так и не удосужившись выучить правила.
Программисты привыкли, что если код не засбоит хотя бы один раз,
то он будет работать во всех случаях.  Сигналы оказались для них
хорошо замаскированной ловушкой, из которой всем нам предстоит еще
долго выкарабкиваться (о последствиях неаккуратной работы с сигналами
для безопасности см. статью "Delivering Signals for Fun and Profit":
<a href="http://razor.bindview.com/publish/papers/signals.txt">http://razor.bindview.com/publish/papers/signals.txt</a>).

Академическое сообщество пользователей Unix всегда поощряло
"экспериментальный" стиль программирования, когда во главу угла
ставится сам факт реализации той или иной возможности, а не качество
решения.  В 1986 году даже почтенный Chris Torek допускал высказывания
вроде этого: "Хотя вызывать exit(3) из обработчика сигнала не вполне
надежно, на практике это не создает никаких проблем".  Впрочем, сам
мистер Torek отрекся от подобной ереси к началу 1990-х; зато
недостатка в программистах, обрабатывающих сигналы по принципу
"авось пронесет", и книгах, дающих сомнительные советы, не ощущается
до сих пор.

Что удивительно в такой ситуации, правила "игры в сигналы" на самом
деле весьма просты.  Поэтому хотелось бы их четко сформулировать и
указать на основные следствия из них.  Для начала я попытаюсь это
сделать для случая традиционных сигналов POSIX в однонитевой среде.
Комментарии и дополнения приветствуются.



ПРАВИЛА ИГРЫ В СИГНАЛЫ UNIX

Правило 1

Посланный процессу сигнал может быть проигнорирован, заблокирован,
или доставлен.  Под доставкой понимается действие по умолчанию или
вызов назначенного обработчика.  Рассмотрим эти случаи по отдельности.

1. Если сигнал игнорируется, то он не оказывает никакого воздействия
на процесс.  В частности, не прерываются по EINTR прерываемые
операции.

2. Если сигнал блокируется, то его обработчик будет вызван один раз
(независимо от того, сколько раз был послан сигнал) после снятия
блокировки.

3. Если сигнал обрабатывается по умолчанию как "отвергнуть сигнал"
(discard signal), то это полностью эквивалентно его игнорированию
(см. п. 1.1).  В некоторых руководствах это действие явно именуется
"ignore".  Действиями по умолчанию, в зависимости от типа сигнала,
могут также быть "завершить процесс" (возможно, с записью образа
памяти), "приостановить процесс" и "продолжить процесс".

4. Если процесс назначил сигналу собственный обработчик и сигнал
должен быть доставлен, то будет вызван этот обработчик.

	Если у сигнала установлен через sigaction(2) флаг SA_RESETHAND,
	то эмулируется поведение SysV signal(): обработчик сигнала будет
	установлен равным SIG_DFL (обработка по умолчанию) в момент
	доставки, т.е. непосредственно перед вызовом текущего
	обработчика.

	На время вызова обработчика текущий сигнал блокируется,
	если не установлен флаг SA_NODEFER (то есть, сигнал добавляется
        к маске, описанной в sa_mask).  Это необходимо, чтобы
	избежать зацикливания обработчика.

	Обработчику передается номер текущего сигнала, что позволяет
	использовать один обработчик для нескольких сигналов. Возможна
        передача дополнительной информации (см. SA_SIGINFO в SUS).

	Между посылкой сигнала и его доставкой может пройти
	неограниченное количество времени, даже если сигнал не
	заблокирован.  Следовательно, один и тот же сигнал может
	быть послан процессу несколько раз перед тем, как он будет
	доставлен.  Тем не менее, обработчик будет вызван единожды,
	так как система запоминает только сам факт посылки каждого
	сигнала.


Правило 2

Любая операция может быть временно прервана вызовом обработчика
асинхронного сигнала, если на момент ее выполнения сигнал не
заблокирован и не игнорируется.

	Сигналы посылаются и доставляются асинхронно в подавляющем
	большинстве случаев.  Существует, по сути, лишь один случай
	синхронной посылки сигнала: когда процесс посылает сигнал
	сам себе, с помощью функций abort(3) или raise(3).  Согласно
	C99 и SUSv3, если в ответ на raise(3) должен быть вызван
	обработчик сигнала, raise(3) может вернуть управление только
	после того, как это сделает обработчик.

	В системах, совместимых с POSIX, вызов функции
		raise(signo);
	должен быть эквивалентен вызову конструкции:
		kill(getpid(), signo);
	Значит, в POSIX такую конструкцию можно рассматривать как
	еще один способ синхронной посылки сигнала.  Раздел SUSv3,
	посвященный функции kill(), подробно обсуждает посылку
	процессом сигнала самому себе и указывает, что в этом случае
	сигнал должен быть доставлен до того, как kill() вернет
	управление.


Правило 3

Существует ровно один тип статических данных, sig_atomic_t, переменную
которого может установить обработчик асинхронного сигнала.  Поведение
приложения не определено, если асинхронно вызванный обработчик
обращается к статическим данным любым другим способом.

	По-видимому, это весьма жесткое ограничение связано с
	поддержкой архитектур, в которых обработчик асинхронного
	сигнала не может напрямую обращаться к основной памяти
	процесса.


Правило 4

Если обработчик асинхронного сигнала завершается возвратом, то
текущая операция может быть продолжена или прервана, в зависимости
от типа операции и значения флага SA_RESTART для этого сигнала.
Есть несколько случаев.

1. Если для текущего сигнала не установлен флаг SA_RESTART, то
некоторые системные вызовы будут прерваны с ошибкой EINTR.  Если
же флаг SA_RESTART установлен, то выполнение этих вызовов будет
продолжено.

	Список прерываемых вызовов может быть приведен в sigaction(2);
	это вызовы ввода-вывода и wait(2).  SUSv3 такого списка не
	приводит, однако говорит, что сигнал без SA_RESTART прерывает
	любой вызов, который может возвращать ошибку EINTR.

2. Функции семейства sleep (sleep(3), nanosleep(2) и т.п.) будут
прерваны любым доставленным сигналом, вне зависимости от наличия у
него флага SA_RESTART.

3. Вызов connect(2) в блокирующем режиме будет перван любым
доставленным сигналом, независимо от его флагов, однако сама операция
установки соединения будет продолжена в асинхронном режиме.  Об
окончании операции можно узнать, передав дескриптор в poll(2) или
select(2): он будет помечен как готовый к записи.

4. Вызовы select(2), pselect(2) и poll(2) могут быть прерваны
сигналом.

	Согласно SUSv3, poll(2) прерывается любым доставленным
	сигналом; будут ли select(2) и pselect(2) учитывать флаг
	SA_RESTART, определяет реализация.

5. Выполнение кода процесса и остальных системных вызовов будет
продолжено.


Следствия _для асинхронных сигналов_

1. &#091;Из п. 2&#093; Из обработчика сигнала нельзя выполнять общий c другими
частями процесса нереентерабельный участок кода, если он не защищается
всякий раз путем блокировки соответствующих сигналов.

	Здесь нереентерабельность понимается в широком смысле как
	зависимость по статическим данным, требующим сериализации
	доступа.  Таким образом, нереентерабельной может быть как
	отдельная функция, так и целая библиотека.  Если несколько
	участков кода обращаются к общим данным, требующим сериализации,
	то все они будут взаимно нереентерабельны.  В англоязычной
	литературе есть более точный термин "async-signal-safe", то
	есть, безопасный по отношению к асинхронным сигналам.

2. &#091;Из п. 2, с. 1&#093;  Из обработчика сигнала нельзя вызывать
нереентерабельные библиотечные функции (н.б.ф.), если только
устройством программы не гарантируется, что на момент _каждого_
вызова _любой_ н.б.ф. все сигналы, чьи обработчики содержат вызовы
_любых_ н.б.ф., не будут заблокированы.

	Так как внутренние зависимости между н.б.ф. полностью зависят
	от реализации, вложенный вызов _любой_ н.б.ф.  может привести
	к неопределенному поведению _всех_ н.б.ф.  К примеру,
	изрядное количество библиотечных функций явно или неявно
	вызывают malloc(3); так что разрушение структур malloc(3)
	в результате вложенного вызова приведет к сбою многих б.ф.

	Стандарт C99 утверждает, что из обработчика асинхронного
	сигнала можно вызывать только abort(3), _exit(2), _Exit(),
	а также signal(3) с первым аргументом, равным номеру текущего
	сигнала &#091;C99 #7.14.1.1&#093;.  Стандарты POSIX и SUS приводят
	довольно объемистый список реентерабельных функций.  В
	прочих системах этот список, очевидно, определяется
	реализацией.

3. &#091;Из п. 1.4, п. 2&#093; Выполнение обработчика сигнала может быть
прервано очередным доставленным сигналом.  Чтобы избежать прерывания,
необходимо заблокировать все или некоторые сигналы на время работы
чувствительного участка в обработчике.  Проще всего это делать,
указав маску sa_mask в параметре sigaction(2); эта маска будет
атомарно установлена на входе в обработчик, а на выходе из него
будет восстановлено предыдущее значение маски сигналов.

4. &#091;Из с. 1, с. 3&#093; Если один нереентерабельный обработчик установлен
для нескольких сигналов, то на время работы нереентерабельного участка
нужно блокировать все эти сигналы.

5. &#091;Из п. 2, п. 3&#093; Необходимо использовать модификатор volatile,
чтобы указать компилятору на асинхронность изменения переменной типа
sig_atomic_t.

6. &#091;Из п. 3&#093; Не гарантируется, что обработчик сигнала может читать
статическую переменную, даже если она -- типа sig_atomic_t.

	Учитывая исторически сложившуюся практику, можно считать
	чтение переменной типа sig_atomic_t из обработчика сигнала
	ограниченно переносимым.

7. &#091;Из п. 2, п. 3&#093; Можно использовать только простое присваивание
переменным sig_atomic_t.  В частности, над ними не следует использовать
операции ++ и --.  Это касается как обработчиков сигналов, так и
основного потока (конечно, если соответствующие сигналы не заблокированы
на момент операций с переменной типа sig_atomic_t).

	В архитектуре RISC нет атомарных арифметических операций над
	ОЗУ.  В архитектуре CISC они есть, но компилятор не обязан их
	использовать, например, из соображений оптимизации.

8. &#091;Из п. 3&#093; Если стандартная библиотечная функция, вызванная из
обработчика сигнала, вернула ошибку, то значение переменной errno
может быть не определено.

9. &#091;Из п. 2&#093; Вызов даже реентерабельной библиотечной функции из
обработчика сигнала может привести к изменению значения переменной
errno.  Следовательно, если обработчик вызывает б.ф., то он должен
вначале сохранить значение errno, а перед возвратом восстановить его.

	Правило 3 и следствие 8 исключают следствие 9.  Проблема
	здесь в том, что современные стандарты признают исторически
	сложившуюся практику обращения к статическим переменным
	вопреки правилу 3, но крайне не поощряют ее.  Пока что это
	приводит к подобным противоречиям.

10. &#091;Из п. 2, п. 3, с. 1&#093; "Трюк" с возвратом из обработчика сигнала
через longjmp(3), кочующий из книги в книгу (даже W.R.Stevens
приводит его), следует использовать с большой осторожностью.
Во-первых, longjmp(3) не восстановит статических переменных libc и
структуру кучи malloc(3) на момент вызова setjmp(3), а значит, он
ничем не поможет в решении проблемы реентерабельности.  Во-вторых,
вызов longjmp(3) из обработчика обладает ограниченной переносимостью.

	Изначально longjmp(3) из обработчика сигнала использовался,
	чтобы обойти особенность 4.2BSD.  Системные вызовы 4.2BSD
	всегда продолжались после обработки сигнала, если обработчик
	возвращал управление.  Приходилось совершать longjmp(3),
	чтобы прервать системный вызов.

	Еще одно историческое применение longjmp(3) из обработчика
	состояло в обходе изьяна pause(2).  В системах без sigsuspend(2)
	или sigpause(2) невозможно было гарантировать, что сигнал
	не придет до вызова pause(2).  Если сигнал посылался
	однократно, как SIGALRM по истечению таймера, то приложение
	могло "зависнуть".  Для решения этой проблемы управление
	из обработчика явно передавали через longjmp(3).  W.R.Stevens
	приводит пример использования longjmp(3) в обработчике
	именно для этого случая.

	Существует как минимум одна среда, претендующая на совместимость
	с POSIX, в которой выход из обработчика сигнала через
	longjmp(3) приводит к сбою приложения.  Речь идет о Win32
	и сигнале SIGINT.  Этот сигнал посылается консольному
	приложению при нажатии ^C и доставляется в специально
	отведенную нить, даже если приложение спроектировано как
	однонитевое.  Конечно, этот прецедент может показаться
	далеким от реалий Unix.  Однако он иллюстрирует разнообразие
	особенностей, с которыми можно столкнуться в POSIX-совместимых
	системах.

11. &#091;Из п. 2&#093; Блокировка сигналов часто должна выполняться неразрывно
с другой операцией.  Для этого существует ряд стандартных механизмов
и функций.

	Согласно странице руководства sigaction(2) в системах на
	основе BSD, несколько одновременно ожидающих доставки
	сигналов будут доставлены так, что каждый последующий сигнал
	прервет обработчик предыдущего перед его первой машинной
	командой.  Таким образом, избежать дальнейшего вложенного
	вызова обработчиков можно, лишь атомарно установив маску
	сигналов перед входом в текущий обработчик.  Для этого служит
	маска sa_mask, передаваемая как член структуры sigaction в
	sigaction(2).

	Чтобы приостановить выполнение программы до прихода
	определенного сигнала (или любого из заданного множества
	сигналов), существует системный вызов sigsuspend(2).  Его
	использование предполагает, что в остальное время интересующий
	нас сигнал (или их множество) заблокирован, иначе можно его
	упустить до вызова sigsuspend(2).  Но даже если sigprocmask(2)
	вызвать непосредственно перед sigsuspend(2), все равно
	образуется временное окно, на протяжении которого ожидаемый
	сигнал может оказаться доставлен.  Поэтому sigsuspend(2)
	принимает в качестве аргумента маску сигналов, которую
	атомарно устанавливает на время ожидания.

	Системный вызов pselect(2) фактически совмещает в себе
	функциональность select(2) и sigsuspend(2).  Поэтому он
	также принимает в качестве одного из аргументов маску
	сигналов, которую атомарно устанавливает на время ожидания
	событий.

12. &#091;Из п. 2, с. 1&#093; Для завершения процесса из обработчика сигнала
следует использовать _exit(2) (POSIX) или _Exit() (C99), которые
не имеют побочных эффектов, в отличие от exit(3).

	Побочными эффектами exit(3) являются вызов зарегистрированных
	с помощью atexit(3) деструкторов, закрытие потоков stdio,
	удаление временных файлов и т.п.  Все это наверняка повлечет
	вызов н.б.ф.

13. &#091;Из п. 4.1&#093; Если хотя бы у одного сигнала, для которого установлен
обработчик, нет флага SA_RESTART и этот сигнал не заблокирован, то
по EINTR может быть прервана _любая_ стандартная библиотечная функция
ввода-вывода.


Практические соображения

При планировании проекта стоит определить границы его переносимости,
так как требования разных стандартов могут заметно отличаться или
даже противоречить друг другу, что мы уже видели ранее.  Если
ограничиться средой Unix, то наиболее здравым выбором, по-видимому,
будет текущая версия SUS.

	Обращение из обработчика асинхронного сигнала к статическим
	данным вопреки правилу 3 может считаться ограниченно
	переносимым, так как работает в большинстве Unix-подобных
	систем.  Использовать его можно на свой страх и риск, однако
	следует иметь ввиду возможные последствия для надежности и
	переносимости приложения.

Не надо относиться к сигналам как к грому и молнии.  В аккуратно
написанной программе всегда известно, какие сигналы в данный момент
следует принимать и обрабатывать, а какие лучше держать заблокированными
или игнорировать.  Зачастую это не требует значительных усилий или
изменений в структуре программы -- достаточно четко осознавать,
почему тот или иной сигнал не повредит, скажем, при вызове функции
ввода-вывода.

Если в вашем проекте сигналы большую часть времени разблокированы
и у некоторых из них не установлен флаг SA_RESTART, то может быть
удобно сократить до минимума число вызовов функций ввода-вывода.
Нужно быть готовым перезапустить каждый такой вызов, если он вернет
EINTR или выполнит операцию не полностью.  При большом количестве
вызовов (например, при посимвольном вводе-выводе посредством stdio)
это потребует соответствующего числа практически повторяющихся
"оберток", что отрицательно скажется как на производительности, так
и на удобочитаемости исходных текстов.

Наиболее простой и безопасный подход к обработке сигналов -- когда
обработчик устанавливает флаг типа sig_atomic_t, а основной поток
проверяет его и предпринимает необходимые действия.  Если при этом
необходимо прерывать некоторые операции ввода-вывода, то следует или
блокировать сигналы на время остальных операций ввода-вывода, или
особо обрабатывать ошибку EINTR после _всех_ операций ввода-вывода.

В сложных случаях может оказаться удобнее эмулировать синхронные
сигналы.  Для этого можно держать сигналы заблокированными большую
часть времени и разблокировать их только в специально отведенных,
реентерабельных точках программы.  Особенно удобным для этой цели
является системный вызов pselect(2), который позволяет атомарно
устанавливать маску сигналов на время своего выполнения.  Конечно,
это внесет задержку между отправкой сигнала и его обработкой.

	В системах, где pselect(2) отсутствует, его можно частично
	эмулировать, используя запись из обработчика сигнала в канал
	(pipe).  Для этого необходимо:

	а) создать канал;
	б) установить на обоих концах канала режим неблокирующего
	   ввода-вывода;
	в) установить обработчик, который станет записывать в этот
	   канал 1 байт (любой, т.к. доставка через канал не будет
	   гарантированной) и устанавливать флаг в переменной
	   типа volatile sig_atomic_t;
	г) включить читаемый дескриптор сигнального канала в
	   обработку poll(2)/select(2);
	д) разблокировать сигнал;
	е) вызвать poll(2)/select(2);
	ж) заблокировать сигнал;
	з) при наличии данных в сигнальном канале читать их оттуда
	   для очистки буфера;
	и) если флаг установлен:
		- сбросить флаг;
		- предпринять необходимые действия;
	к) вернуться к д).

	Смысл записи в канал состоит в том, что poll(2)/select(2)
	вернет управление сразу, если сигнал уже был доставлен в
	обработчик.  Иначе poll(2)/select(2) стал бы ждать других
	событий, и реакция на сигнал произошла бы с задержкой.
	Конечно, возможна потеря сигнала, если буфер сигнального
	канала уже заполнен.  Однако за счет установки и проверки
	флага хотя бы один экземпляр сигнала будет когда-нибудь
	замечен, а это вполне согласуется с моделью сигналов POSIX.

Так как сложные схемы на основе сигналов очевидно ограничены и плохо
переносимы, с сигналами всегда стоит придерживаться принципа K.I.S.S.:
"Keep it simple, stupid".  Если вы выучили правила и видите, что
нетривиальное использование сигналов причиняет слишком много
неудобств, то вам пора рассмотреть другие средства IPC для вашего
проекта.


Заключение

Автор хотел бы искренне поблагодарить читателей эхи (телеконференции
FidoNet) RU.UNIX.PROG за ценные замечания и идеи для данной статьи.

Yar Tikhiy &lt;<A HREF="mailto:yar@comp.chem.msu.su">yar@comp.chem.msu.su</A>&gt;

$Id: signal.txt,v 1.48 2003/07/22 15:50:49 yar Exp $


</PRE><BR>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=1 BGCOLOR="#B0B190" WIDTH="100%">
<TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 BGCOLOR="#E9EAD6" ALIGN=CENTER WIDTH="100%">
<TR BGCOLOR="#000000"><TD COLSPAN=7><IMG SRC="/p.gif" HEIGHT=1 WIDTH=1 ALT=""></TD></TR>
<TR ALIGN=CENTER>
<TD><small><A HREF="/cgi-bin/opennet/jump.cgi?name=unix_signals.txt&ref=prev">&lt;&lt; Предыдущая</A></TD>
<TD><small><A HREF="/cgi-bin/opennet/jump.cgi?name=unix_signals.txt&ref=index">ИНДЕКС</A></TD>
<TD><small><A HREF="/search.shtml">Поиск в статьях</A></TD>
<TD><small><A HREF="/cgi-bin/opennet/jump.cgi?name=unix_signals.txt&ref=raw">src</A></TD>
<TD><small><A HREF="/cgi-bin/opennet/jump.cgi?name=unix_signals.txt&ref=setbookmark">Установить закладку</A></TD>
<TD><small><A HREF="/cgi-bin/opennet/jump.cgi?name=unix_signals.txt&ref=getbookmark">Перейти на закладку</A></TD>
<TD><small><A HREF="/cgi-bin/opennet/jump.cgi?name=unix_signals.txt&ref=next">Следующая &gt;&gt;</A></TD>
</TR><TR BGCOLOR="#000000"><TD COLSPAN=7><IMG SRC="/p.gif" HEIGHT=1 WIDTH=1 ALT=""></TD></TR>
</TR></TABLE></TD></TR></TABLE>
<br><table class="thdr"><tr><td style="text-align:left;"><b>Обсуждение</b></td>
<td align=right  style="font: 80% Arial;">[
<a href="/cgi-bin/openforum/rss_forum.cgi?forum=vsluhforumID3&om=71237" style="color: rgb(255, 102, 0);">RSS</a>
]</td></tr></table>

<table class="ttxt">
<tr bgcolor="E9EAD6"><td id=ln71237 class=ctxt>



<script language="JavaScript" src="/ajax20.js"></script>
<script language="JavaScript">
var idx_nextans_list = {}; 
var idx_prevans_list = {}; 
var idx_ans_map = {71237: {}}; 
</script>

<a name="1"></a><table class=cblk id="msgshow_1"><tr><td class=chdr><li><a href="/openforum/vsluhforumID3/71237.html#1">1</a>, <a href="/~gpr">gpr</a> (<span title='Ник без авторизации'>?</span>), 21:50, 08/10/2010  [<a href="/cgi-bin/openforum/vsluhboard.cgi?az=post&om=71237&forum=vsluhforumID3&omm=1" rel="nofollow">ответить</a>] &nbsp;<script>s_n_a2(1286553058,'gpr','vsluhforumID3', 71237, 1)</script>
</td><td class=chdr2><span id="vt_2_3_71237_1" class=vt_d2><a href="#" onClick="return o_vote('2_3_71237_1',1);" title="Полезно, одобряю"><span class=vt_p>+</span></a>/<a href="#" onClick="return o_vote('2_3_71237_1',-1);" title="Мусорный комментарий"><span class=vt_m>&ndash;</span></a></span></td></tr><tr><td class=ctxt colspan=2 style="border-left:3px solid #D9DAC6;">
<a href="/~gpr"><img src="/avatar/5c5c27fdac161fb5686690af2805ee19.jpg" width=40 height=40 border=0 align=right></a>Правило 1 пункт 2 не совсем верен.
<p>Например в свежей freebsd (9-current) сигнал помещается в очередь, и при разблокировке сигнала обработчик будет вызван столько раз, сколько раз был послан сигнал.
<br></td></tr><tr><td colspan=2>&nbsp;</td></tr></table>

<div id=actshow_0_1>

</div>

<a name="2"></a><table class=cblk id="msgshow_2"><tr><td class=chdr><li><a href="/openforum/vsluhforumID3/71237.html#2">2</a>, <a href="/~icegood">icegood</a> (<span title='Авторизован'>ok</span>), 16:27, 07/12/2010  [<a href="/cgi-bin/openforum/vsluhboard.cgi?az=post&om=71237&forum=vsluhforumID3&omm=2" rel="nofollow">ответить</a>] &nbsp;<script>s_n_a2(1291721234,'icegood','vsluhforumID3', 71237, 2)</script>
</td><td class=chdr2><span id="vt_2_3_71237_2" class=vt_d2><a href="#" onClick="return o_vote('2_3_71237_2',1);" title="Полезно, одобряю"><span class=vt_p>+</span></a>/<a href="#" onClick="return o_vote('2_3_71237_2',-1);" title="Мусорный комментарий"><span class=vt_m>&ndash;</span></a></span></td></tr><tr><td class=ctxt colspan=2 style="border-left:3px solid #D9DAC6;">
<a href="/~icegood"><img src="/avatar/2664e97e1cf0ad27cae5d11c4ba3f8fe.jpg" width=40 height=40 border=0 align=right></a>13 пункт -жесть!
<br></td></tr><tr><td colspan=2>&nbsp;</td></tr></table>

<div id=actshow_0_2>

</div>

<a name="3"></a><table class=cblk id="msgshow_3"><tr><td class=chdr><li><a href="/openforum/vsluhforumID3/71237.html#3">3</a>, <a href="/~DiriJor">DiriJor</a> (<span title='Ник без авторизации'>?</span>), 16:56, 16/04/2011  [<a href="/cgi-bin/openforum/vsluhboard.cgi?az=post&om=71237&forum=vsluhforumID3&omm=3" rel="nofollow">ответить</a>] &nbsp;<script>s_n_a2(1302951369,'DiriJor','vsluhforumID3', 71237, 3)</script>
</td><td class=chdr2><span id="vt_2_3_71237_3" class=vt_d2><a href="#" onClick="return o_vote('2_3_71237_3',1);" title="Полезно, одобряю"><span class=vt_p>+</span></a>/<a href="#" onClick="return o_vote('2_3_71237_3',-1);" title="Мусорный комментарий"><span class=vt_m>&ndash;</span></a></span></td></tr><tr><td class=ctxt colspan=2 style="border-left:3px solid #D9DAC6;">
<a href="/~DiriJor"><img src="/avatar/9d17db8808dea28217d3f39233fd638c.jpg" width=40 height=40 border=0 align=right></a>идеальная статья большое спасибо долго искал что то подобное.
<br></td></tr><tr><td colspan=2>&nbsp;</td></tr></table>

<div id=actshow_0_3>
</div>

<script language="JavaScript">
var hidden_msg = new Array(0); 
var hidden_idx = new Array(0,1); 
var idx_level1_list = {71237: [1,2,3]}; 
if (text_type == 1){ open_block(71237,3,hidden_msg,1);}
</script>

<br>
</tr></td>
</table>
<table class="thdr">
<tr><td><b>&nbsp;Добавить комментарий</b></td></tr>
</table>

<table class="ttxt">
<tr><td>
<form method="post" action="https://www.opennet.ru/cgi-bin/openforum/vsluhboard.cgi">
<input type=hidden name="om"  value="71237">
<input type=hidden name="key_section" value="topic">
<input type=hidden name="key_sub" value="dev">
<input type=hidden name="key_item" value="unix_signals">
<input type=hidden name="forum" value="vsluhforumID3">
<input type=hidden name="omm" value="">
<input type="hidden" name="az" value="a_mesg">

<table>
<tr><td>Имя:</td><td><input type=text name="name" 
 size=30></td></tr>
<tr><td>E-Mail:</td><td><input type=text name="email" 
 size=30 title="Не обязательное поле. Для отправки ответов следует указать перед адресом знак '!' или '!!' для скрытия адреса"></td></tr>
<tr><td>Заголовок:</td><td><input type=text name="subject" 
 value="Правила использования сигналов в Unix (signal proccess faq select gcc)" 
 size=30 maxlength=63></td></tr>
<tr><td valign=top colspan=2>Текст:<br><textarea name="body" COLS=40 ROWS=8 WRAP="virtual" onClick="TxtResize(this)" style="width:100%;max-width:800"></textarea></td></tr>
<tr><td></td><td>
<!-- INPUT TYPE="SUBMIT" NAME="preview" VALUE="Посмотреть" -->
<INPUT TYPE="SUBMIT" NAME="post" VALUE="Отправить">
</td></tr>
</table>
</form>
</td></tr>
</table>
<br>
<!--htdig_noindex-->
<noindex>
<br>


</noindex>
<!--/htdig_noindex-->


<!-- footer -->
<!--htdig_noindex-->
<br><br>
<div style="background-color: #E9EAD6; width:100%; height: 61px;">
<div style="margin-right: 20px; float:left; line-height:60px; vertical-align: middle; margin-left: 10px; font-size: 120%;">
Спонсоры:
</div>
<div style="float:left; height:60px;  line-height:60px; margin-left: 20px;">
<a style="align: middle;" target=_blank href="https://www.postgrespro.ru"><img src="/img/pp_200.png" height=60 width=200 alt="PostgresPro"></a>
</div>
<div style="float:left; height:60px;  line-height:60px; margin-left: 20px;">
<a style="align: middle;" target=_blank href="https://ishosting.com/ru"><img src="/img/inferno2.png" height=60 width=200 alt="Inferno Solutions"></a>
</div>
<div style="float:right; height:60px;  line-height:60px;  margin-left: 15px;">
<a style="align: middle;" target=_blank href="http://hoster.ru/?utm_source=site&utm_medium=banner&utm_campaign=opennet"><img src="/img/dh143x60t.png" height=60 width=143 alt="Hosting by Hoster.ru"></a>
</div>
<div style="float:right;  height:60px;  line-height: 60px; vertical-align: middle;font-size: 120%;">
Хостинг:
</div>

</div>
<div style="clear: both;"></div>


<br>
<TABLE class=ttxt style="border-top: 3px solid #C9CaB6;">
<TD WIDTH="35%">
<A HREF="/cgi-bin/opennet/bookmark.cgi">Закладки на сайте</A><BR>
<A HREF="/cgi-bin/opennet/bookmark.cgi?submit=add" target="blank_">Проследить за страницей</A>
</TD>
<TD WIDTH="65%" ALIGN=RIGHT>
Created&nbsp;1996-2022&nbsp;by <B><A HREF="/contact.shtml" title="email maxim.chirkov@gmail.com">Maxim&nbsp;Chirkov</A></B><BR>
<A HREF="https://www.opennet.ru/add.shtml">Добавить</A>, <A HREF="https://www.opennet.ru/donate.shtml" style="color: #C00000;">Поддержать</A>, <A HREF="https://www.opennet.ru/banners2.shtml">Вебмастеру</A>
</TD>
</TR>
</TABLE>
<br><br>

</form>
<!--/htdig_noindex-->
<!-- end of footer -->
<!--
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-123449-1', 'auto');
    ga('send', 'pageview');
</script>
-->




</BODY></HTML>
