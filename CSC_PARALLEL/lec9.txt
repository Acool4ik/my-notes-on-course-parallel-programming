	Лекция 9 (Очередь Michael-Scott. Flat-combining)

Линеаризуемый алгоритм - тот который выполняется корректно при
любых расстановках точер линеаризуемости в разных потоках

Пример с вызовом функции из двух потоков в один момент времени:

call f1 in th1
|---------------|
   ^
   |
точка линеариз в th1


call f1 in th2
|---------------|
	^
	|
точка линеариз в th2

------------------------------------> time

Если алгоритм корректен, то он не зависит от относительного порядка
точек линеаризуемости. Т.е. таких критических точек для многопоточных
программ (например: обращение к критической секции)

Важное напоминание, что lock-free алгоритмы не должны никого ждать.
Если мы отключим несколько потоков в произвольный момент времени, то
оставшиеся должны окончить работу

	Очередь Michael-Scott
Вставку производим 2-мя CAS операциями
Удаление 1-й CAS операцией

Каждый поток помогает нам перетаскивать хвост, если тот указывает не на
последний элемент. 

Таким образом соблюдается инвариант, что:
хвост отстает от последнего элемента не более чем на 1 позицию, иначе бы
другой поток увидел бы это и помог нам перетащить указатель.

Мы не проверяем статус фикса хвоста в CAS операции, потому что нам это
безразлично. Если у нас не прошел CAS значит кто-то другой сделал это и 
при этом сделал именно этот CAS, т.к. все другие потоки сначала смотрят
на это корректность хвоста и фиксят его.

	
	Flat-combining
Специфичный подход к проектированию структур данных.
Адаптируем интерфейс потоко-опасной структуры к потоко
безопасному интерфейсу

Использует TLS для создание структуры для каждого потока.


			Flat combining
Никакого отношения к lock-free не имеет

	предоставляет	---------------------------------
	интерфейс ---->	|try_lock_global_mtx		|
		  |	|TLS1	TLS2	TLS3 .. TLSN	|
don't thread-safe |	|-------------------------------|
structure	  |	|	|	|	|	| действия для каждого
---------	  |	--------------------------------- потока (список публикаций)
|	|	  |	|	
|	|----------	|
---------		|
			|
			предоставляет интерфейс:
			
			* do (<enum_action>, [args...]) - публикация операции
			| Считаем атомарным действием и захватывать примитив
			нам для этого не требуется
			| Для каждого потока можно хранить лишь 1 публикацию, при
			попытке добавить вторую это станет блокирующей операцией

			* check (<операция>) - если некому выполнять операции
			то мы становимся рабочей силой и выполняем все операции
			для всех потоков (с захватом блокировки). 
			| Если кто-то уже за нас сделал это, то просто забираем 
		--------результат
		|
Если у нас не получилось стать комбайнером и при этом действие ещё никто
не выполнил, значит у кого-то получилось захватить примитив и этот кто-то
в процессе выполнения задач. В таком случае мы просто продолжаем работу 
и пробуем позже, когда нам это будет удобно

Возвращаемое значение после действия будет лежать в TLS, а не публикация 

Ожидать мы можем по любой стратегии: sleep, spinlock, leazy check, и т.д.

	ПЛЮСЫ:
1) Имея такой фреймворк, можем быстро оборачивать методы не потоко безопасных
структур.
2) Унифицированный интерфейс
3) Реализация специфичной логики в соответствии с парами операци, к примеру:
push + pop = ничего не делать
4) Повышается локальность кешей, т.к. только один поток работает со структурой
в 1 момент времени

Локальность кешей == меньше кеш-линий шарятся между другими процессорами
* Это значит что сильно уменьшается отработка протоков когерентности
кешей процессоров

См. benchmarks в статье к лекции
