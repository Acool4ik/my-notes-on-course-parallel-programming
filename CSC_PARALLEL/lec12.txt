	Лекция №12 (OpenMB IntelTBB)
Пул потоков - шаблон проектирования для || выполнения задач.

	(1) Очередь задач
-----------------------------------------
| task1	| task2	| task3 | ...	| taskN |
|	| 	|	|	|	|
-----------------------------------------
   |	   |	    |_______ 	отображение задач		
   |       |		   |	на потоки, которые из выполняют
---------------------------------
| th1	| th2	| ...	| taskK |
|	| 	|	|	|
---------------------------------
   |	   |	    _______|
   |	   |	    |
-----------------------------------------
|future1|future2|future3| ...	|futureN|
|	| 	|	|	|	|
-----------------------------------------
Потоки (жиксированное число или изменяемое)
* Если задач нет для потока, то тот просто спит.
* Синхронизируем сон/работу через condition variables

Итого: имеем потокобезопасную очередь, горячие потоки и механизм
отображения задач/future object на потоки с оповещением этих потоков

В ответ на добавление задачи в очередь получаем объект, который
называется future. Это универсальный объект, во многих языках,
который позволяет отслеживать ход выполнения асинхронной задачи.

Future methods (интерфейс взаимодействия с потоком)
	- get - блокирующее ожидание результата
	- isFinish - проверка состояния
	- cancel - отмена потока

	(2) OpenMP (open multi processing)
Интерфейс для многопоточного программирования, развивается но слабо
Решение для Fortran, C/C++

* Области видимости переменных:
Существуют директивы препроцессора, определяющие поведение внешних
переменных по отношению к внутренним.
	- sharing (внешние переменные передаются по указателю)
	- private (внешние переменных никак не шарятся, а просто объявляются
	локально)
	- и т.д.

* Средства (директивы )синхронизации:
	- возможность объявлять критич. секции
	- явно объявлять атомарные операции

ИТОГО: xорошо использовать для простых вычислений, которых ложатся 
в вилочный параллелизм

	(3) IntelTBB (intel threading blocks)
Фреймворк || программирования для С++. Очень обширное количество
реализованных решений. Очень мощный инструмент.

Что имеется:
	- параллельные алгоритмы
	- многопоточные контейнеры
	- аллокаторы памяти
	- примитивы (лучше использовать std::, об этом
	говорит и сам Intel)
	- планировщики задач

Единицей планирования для TBB является 'задача' (TBB Task). При этом мы 
не имеем возможность создать несколько pool-ов потоков, т.к. все задачи 
проходят через главный планировщик, который скрыт от нас.

--------------------------------------
 потоки | очередь задач каждого потока
--------------------------------------
|	| ___    ___    ___   	|
| th1	| |_| -> |_| -> |_| ->	|
|	|			|
---------------------------------
|	| ___    ___    ___	|
| th2	| |_| -> |_| -> |_| ->	|
|...	|			|
---------------------------------
|	| ___			|
| thN	| |_| ->		|
|	|			|
---------------------------------

Где N обычно - это число ядер.
Если задачи у потока закончились, он их может украсть
у другого потока.

С tbb лучше будет работать сам Intel-овский компилятор.
Мы говорим что мы делаем, но не где. И это хорошая абстракция.

Так же появилась такая важная вещь, как 'дерево задач':
	- можно создавать задачи в виде объекта, добавлять
	дочерние задачи как рекурсивный вызов и ждать эти 
	'поддеревья задач'
	// при этом ожидание будет лишь с точки зрения
	выполнения кода построчно, но для потоков никакого
	ожидания не будет

Узким звеном после синхронизации (которую можно избежать), является
работа с памятью. Даже если мы напишем свой аллокатор, он все равно 
будет требовать некоторой координации для выделения памяти.

Решаем это резервированием некоторого количества памяти под каждый поток.
Аналог TLS. (Scalable аллокатор в TBB для || кода)

Есть также cache-align аллокатор. Просто добиваем размер аллоцированной
памяти до значения кратного кеш линии + выравниваем. Это поможет 
избежать ситуации приведенной ниже

	CPU0			CPU1
-----------------	-----------------
|cache lineK	|	| cache lineN	|
---------------------	---------------------
|  x	|  y	| S |	|  x	|  y	| S | <-- shared cache line
---------------------	--------------------- 	  (сост. кеш линии)
   ^				   ^
   |				   |
работаем с 			работаем с 
переменной x			переменной y

* Логически наша работа отлично распаралелена, но в действительности
ядра процессора конкурируют за значения к кеш линиях.
* Такая ситуация называется 'fase sharing'

В транзакционной памяти можно использовать подобный аллокатор, но
совсем не обязательно. Т.к. вряд ли такое являение будет часто влиять
на транзакции

Смена аллокатора вполне естественное явление для контейнера, которая 
не требудет дополнительных усилий. Т.е. не нужно закладиваться заранее
и можно решить отложенно.

	В TBB есть такой шаблон проектирования как pipeline.

---------  x	---------  f(x) ---------  g(f(x))
|	| ----->|	| ----->|	| ---------> и т.д.
---------	---------       ---------

Можно к примеру распараллелить функцию №2 в конвеере.
Так же существует модель графовых вычислений. Расширенный pipeline.


