### Lecture 4

Other primitive synchronize: "condition variables" 
// need for communication between threads
* For example: it solve such task as: "Produsers ans Consumers"

* If exist only two operations: w/r, then we don't need to lock the
data. Because no have difference. Data will'not be safer whatever.
NOTE: for integers with bytes < CPU bit depth => w/r is atomic

	increment in asm: (don't atomic)
1) move - read from RAM
2) inc  - register++
3) move - write back

	Implementation:
pthread_cond_wait(cond, mtx) {
	unlock(mtx) | atomic operation
	// sleep    |
		<-- signal (broadcast)
	// wake up  | WARNING: spurious wake ups	
	lock()
}

NOTE: See example with barrier (other primitive) on lection
// Need for simultaneous starting N threads or other specific logic

* Methods for work with condition variable:
    1) pthread_cond_broadcast   => get up + try lock all threads
WARNING: can call without lock mtx! In Java (for example) it forbidden.
But dinamic analizer (as Valgring) throw warning in this case
    2) pthread_cond_signal      => get up + try lock one thread
    3) pthread_cond_wait        => unlock + sleep, then lock again

* Sleep/Get up in Kernel implemented by signals but it hidden 
from us
WARNING: Exist such bad situations: spurious wakeups!

	ALGORITHMS SYNCHRONIZE FOR STRUCTURE "FORWARD LIST":
Only operations: {delete, insert, find} 
// implementation of set 'abstract structure'

#1) brute synchronize (very slow)
	EXAMPLE:
lock() for all structure
---   ---   ---   ---
| |-->| |-->| |-->| |-->null (forvard list)
---   --    --    ---
unlock() for all structure

#2) Shared_mtx

#3) Slightly synchronize 
// ttep by slep lock/unlock each node (too much memory)

EXAMPLE:        time1
lk/   lk/
ulk + ulk
---   ---   ---   ---
| |-->| |-->| |-->| |-->null (forvard list)
---   --    --    ---
                time 2
      lk/   lk/
      ulk + ulk
---   ---   ---   ---
| |-->| |-->| |-->| |-->null (forvard list)
---   --    --    ---
		time 3
etc...

Summaru:
* 2 locks need (on (k-1)-th and k-th) for deleting k-th element
* 1 lock (on k-1-th) for inserting (but 2 locks for go to the position)
* 2 locks for finding element (2 locks except insert operation)

#4) Copy LIST for each thread and work WITH COPY in thread
// this case ose in over highload systems (as Databases or destrubuted storage system)

	Too hard algs... (will't be in course)
    ---   ---   ---   ---
th1 | |-->| |-->| |-->| |-->null (copy for th1 from master)
    ---   ---   ---   ---
     ^     ^     ^     ^         
     |     |     |     |    pointers for synchronize result
    ---   ---   ---   ---
th2 | |-->| |-->| |-->| |-->null (copy for th2 from master)
    ---   --    --    ---
     ^     ^     ^     ^ 
     |     |     |     |
    ---   ---   ---   ---
th3 | |-->| |-->| |-->| |-->null (copy for th3 from master)
    ---   --    --    ---

