	Lectute #5 Ошибки параллельного программирования
1) * deadlock
valgring - VM for linux, as proxy any actions
	--tool=helgrind - for find deadlocks
	--tool=memcheck - default memory checker
	--tool=massif   - dray image memory=f(time)
	
*helgrind - анализируется журнал захвата и освобождения
примитивов синхронизации, если существует место с разным
порядком захвата - выдает ошибку

*ThreadSanitaizer - more faster, from Google

Эти средства должны понимать, что примитив это примитив.
С нашими собственными примитивами работать не будет.
На spinlocks работать так же не будет.

NOTE: Не забываем про deadlock с fork-ом и захваченным mtx-ом ;)
Т.к. будет всего 1 поток. 
WARNING: В speenlock нет проверки на TID, в отличие от mtx-a



Механизм отображения страниц в новом процессе - ленивый.
Т.е. страницы физически копируются только тогда, когда
в исходном процессе произошло изменение памяти.

POSIX говорит, что OS вправе отказать делать fork в
многопоточном приложении.

В ядре используются не mtx-ы а семафоры, а те в свою очередь
не принадлежат потоку



2) *race-condition - ищем теми же самыми програмными средствами
, но немного другими алгоритмами. (алгоритмически неразрешимая)

NOTE: На проявление race-condition влияет количество ядер CPU и компилятор



3) * инверсия приоритетов - чем больше мы захватили ресурсов, тем
выше у нас приоритет у пранировщика.
чтобы, если приоритет с низким приоритетов получал больше

NOTE: процессорного времени, чтобы скорее освободить ресурс и обратно
упасть в нишу с низким приоритетом


4) * ABA проблема - современные аллокаторы имеют оптимизации и часто
на одно и тоже физическое место может вставиться другой объект

часто полагаемся что разные адреса == разные данные, но в данном случае
эта логика ломается

является большой проблеммой для нативных языков, как C/C++, в которых
нет сборщика мусора

используем свободные 16 бит для реализации счетчика, при каждом добавлении
делаем инкремент, тогда CAS операции проходить не будут

на ARM существуют LL/SC операции
