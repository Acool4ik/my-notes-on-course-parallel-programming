	Lectute 5 (Ошибки параллельного программирования)
1) * deadlock, виды:
valgring - VM for linux, as proxy any actions
	--tool=helgrind - for find deadlocks
	--tool=memcheck - default memory checker
	--tool=massif   - dray image memory=f(time)

*helgrind - анализируется журнал захвата и освобождения
примитивов синхронизации, если существует место с разным
порядком захвата - выдает ошибку

*ThreadSanitaizer - more faster, from Google
compile with flag: -fsanitize

Эти средства должны понимать, что примитив это примитив.
С нашими собственными примитивами работать не будет.
На spinlocks работать так же не будет.

NOTE: Не забываем про deadlock с fork-ом и захваченным mtx-ом ;)
Т.к. будет всего 1 поток. (используем pthread_atfork) 
WARNING: В speenlock нет проверки на TID, в отличие от mtx-a

Механизм отображения страниц в новом процессе - ленивый.
Т.е. страницы физически копируются только тогда, когда
в исходном процессе произошло изменение памяти.

POSIX говорит, что OS вправе отказать делать fork в
многопоточном приложении.

В ядре используются не mtx-ы а семафоры, а те в свою очередь
не принадлежат потоку.


2) *race-condition - ищем теми же самыми програмными средствами
, но немного другими алгоритмами. (алгоритмически неразрешимая)

NOTE: На проявление race-condition влияет количество ядер CPU и компилятор

Пример приводящий к race condition в рассмотренных средствах анализа, но
таковым не являющийся: 
(запись в 1 потоке, а чтение в другом без захвата синхронизации)

class X {
	const int x = 42; // запись
	X() {};
	void new_thread() {
		thread([this]() {
			cout << x << endl; // чтение
		})
	}
}

assert-ы в многопоточных программах нужно использовать.
Даже немного информации поможет при дебаге.


3) * инверсия приоритетов - чем больше мы захватили ресурсов, тем
выше у нас приоритет у пранировщика (если эти ресурсы пытаются 
использовать более высокоприоритетные потоки).

NOTE: чтобы, если приоритет с низким приоритетов захватил примитив
и этот же примитив попытался захватить процесс с более высоким 
приоритетом, то нужно чтобы поток с низким приоритетом получал больше 
процессорного времени, чтобы скорее освободить ресурс и обратно 
упасть в нишу с низким приоритетом.

Проблема долгое время не решалась, т.к. никому не была важна.


4) * ABA проблема - современные аллокаторы имеют оптимизации и часто
на одно и тоже физическое место может вставиться другой объект

			t0				t1
(th1)	---------		---------		(th2)
*A 	--> |   *A	|		|	*B	| <----	*A = pop()
(inter)	|		|		|		|		delete A
		---------		---------		*B = new B()
		|		|		|		|		push(B)
		|		|		|		|		(inter)
		---------		---------		
Физически конструктор для "B" вызвался на тот же участок памяти 
что и ранее для "А" и как следствие, "*B" == "*A", поэтому 
th1 не сможет заметить проблемы, т.к. указатели одни и теже.

На примере со стеком данная проблема безобидна, но в реальных 
условиях имеет серьезные последствия

часто полагаемся что разные адреса == разные данные, но в данном случае
эта логика ломается

является большой проблеммой для нативных языков, как C/C++, в которых
нет сборщика мусора
	
	* Архитектурно зависимый подход:
используем свободные 16 бит для реализации счетчика, при каждом добавлении
делаем инкремент, тогда CAS операции проходить не будут
	
	* Общий подход:
Так же сущ. патентованный алгоритм от IBM - Hazard Pointers.
Помечаем "опасные" указатели как Hazard. Число таких указателей для 
структур данных - фиксированное. И для каждого потока достаточно не
более чем определенное количество Hazard Pointer-ов.

на ARM существуют LL/SC операции

