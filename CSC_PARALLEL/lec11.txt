	Лекция 11 (RCU)
Read Copy Update - специализированный примитив синхронизации
По стратистике структур данных которые читаются - больше

	(1) Рассмотрим RCU в kernelspace:
* Структура ссылочная и иммутабельная (добавление, удаление, поиск)
* Обеспечиваем быструю, независимую работу читателей
NOTE: remove - удаление логическое, а delete - физическое

Существуют 2 метода:
	- rcu_read_lock()
	- rcu_read_unlock()

	ГАРАНТИРОВАННОЕ ЧТЕНИЕ:
Если мы начали чтение в ядре какой либо структуры, то мы его закончим 
на том же вычислительном процессоре (Если не стоит флаг CONFIG_PREEMPT см.
/boot/config*-generic). Т.е. не произойдет никаких прерываний и нас 
не снимут с процесса благодаря этому флагу.

В таком случае имплементация мотодов абсолбтно пустая. Как такое 
реализовать (в kernelspace)?

1) Сначала перекидываем ссылку атомарно

----     ----     ----
|  | --> |  | --> |  |
----     ----     -^--
 |                 |
 -------------------
remove (логическое удаление)

2) forEach((вычислительное ядро) => { ничего не делаю})
т.е. занять ядро - гарантированно узнать, что читатель закончил
работу с этой структурой и эту структуру можно удалить физически (delete).

3) новые же операции чтения не получат удаленную структуру, т.к.
мы атомарно на п.1. перекинули ссылку.

ИТОГО: (с данным флагом) получаем нулевой overhead для читателей.
Сделали потокобезопасную структуру данных при том условии, что
читатели абсолютно ничего не делают.

	(2) Реализация в userspace с флагом
Если мы компилируем ядро с этим флагом, то подход немного меняется:
	1) читатель когда начинает операцию копируем себе некоторую глобальную
	переменную (просто число)
	2) писатель перед удалением инкрементирует это число и ждет, когла
	все читатели перейдут на новую эпоху
	3) новая эпоха у всех читателей в данный момент времени - гарантия того,
	что старую структуру данных никто не может использовать

Подобные структуры данных используются в ядре с 2003, без этой структуры была
бы значительная деградация в производительности.

	(3) Реализация в userspace
Схема работает, только если писателей в 1 момент времени <= 1, поэтому 
для них нужен mtx, чтобы не было конфликта изменения эпох + когда 
регистрируется новый писатель так же захватывается глобальный mtx

В userspace всегда есть механизм регистрации потока, в kernelspace такого нет,
т.к. мы знаем число ядер и можем по всем пройтись.

	(4) специфичный случай
В ядре должна быть обрпботка случая изменения числа ядер. Т.к. в некоторых
серверных решениях можно в процессе работы добавлять модули, воспринимаемые как
вычислительные ядра.

Флаг CONFIG_HOTPLUG_CPU позволяет добавлять ядра на лету.
Существует cтандартная реализация RCU в userspace, см. ldconfig -p

rcu примитив может быть так же рекурсивным по аналогии с рекурсивым mtx.
